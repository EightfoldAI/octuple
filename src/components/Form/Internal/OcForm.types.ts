import type { ReactElement } from 'react';
import type { ReducerAction } from './useForm';

type Validator = (
    rule: OcRuleObject,
    value: OcStoreValue,
    callback: (error?: string) => void
) => Promise<void | any> | void;

interface OcBaseRule {
    /**
     * Match enum value
     * Set type to enum to enable
     */
    enum?: OcStoreValue[];
    /**
     * The length requirement of a field string, number, or array
     */
    len?: number;
    /**
     * type required
     * max length of string, number, or array
     */
    max?: number;
    /**
     * Custom validation message
     * Will be autogenerated if not provided
     */
    message?: string | ReactElement;
    /**
     * type required
     * min length of string, number, or array
     */
    min?: number;
    /**
     * Regex pattern
     */
    pattern?: RegExp;
    /**
     * Required field
     */
    required?: boolean;
    /**
     * Transform value to the rule before validation
     */
    transform?: (value: OcStoreValue) => OcStoreValue;
    /**
     * Normally string |number |boolean |url | email
     * See https://github.com/yiminghe/async-validator#type
     */
    type?: OcRuleType;
    /**
     * Customize rule level `validateTrigger`
     * Must be subset of Field `validateTrigger`
     */
    validateTrigger?: string | string[];
    /**
     * Set required to warningOnly
     * Will not block Form submit
     */
    warningOnly?: boolean;
    /**
     * Fail if only has whitespace
     * only works with type: 'string' rule
     */
    whitespace?: boolean;
}

type OcAggregationRule = OcBaseRule & Partial<OcValidatorRule>;

interface OcArrayRule extends Omit<OcAggregationRule, 'type'> {
    type: 'array';
    /**
     * Validate rule for all array elements
     * valid when type is array
     */
    defaultField?: OcRuleObject;
}

// >>>>>> Info
interface OcValueUpdateInfo {
    type: 'valueUpdate';
    source: 'internal' | 'external';
}

interface OcValidateFinishInfo {
    type: 'validateFinish';
}

interface OcResetInfo {
    type: 'reset';
}

interface OcRemoveInfo {
    type: 'remove';
}

interface SetOcFieldInfo {
    type: 'setField';
    data: OcFieldData;
}

interface OcDependenciesUpdateInfo {
    type: 'dependenciesUpdate';
    /**
     * Contains all the related `InternalNamePath[]`.
     * a <- b <- c : change `a`
     * relatedFields=[a, b, c]
     */
    relatedFields: InternalOcNamePath[];
}

/** Only return partial when type is not any */
type RecursiveOcPartial<T> = T extends object
    ? {
          [P in keyof T]?: T[P] extends (infer U)[]
              ? RecursiveOcPartial<U>[]
              : T[P] extends object
              ? RecursiveOcPartial<T[P]>
              : T[P];
      }
    : any;

type OcValidateMessage = string | (() => string);

export type OcForms = Record<string, OcFormInstance>;

export interface OcFormChangeInfo {
    changedFields: OcFieldData[];
    forms: OcForms;
}

export interface OcFormFinishInfo {
    values: OcStore;
    forms: OcForms;
}

export interface OcFormProviderProps {
    /**
     * The child node
     */
    children?: React.ReactNode;
    /**
     * Triggered when a sub form field updates
     */
    onFormChange?: (name: string, info: OcFormChangeInfo) => void;
    /**
     * Triggered when a sub form submits
     */
    onFormFinish?: (name: string, info: OcFormFinishInfo) => void;
    /**
     * Validation prompt template
     */
    validateMessages?: ValidateMessages;
}

export interface OcFormContextProps extends OcFormProviderProps {
    /**
     * Registers form
     */
    registerForm: (name: string, form: OcFormInstance) => void;
    /**
     * Triggers form field updates
     */
    triggerFormChange: (name: string, changedFields: OcFieldData[]) => void;
    /**
     * Triggers form submit
     */
    triggerFormFinish: (name: string, values: OcStore) => void;
    /**
     * Unregisters form
     */
    unregisterForm: (name: string) => void;
}

export type InternalOcNamePath = (string | number)[];
export type OcNamePath = string | number | InternalOcNamePath;

export type OcStoreValue = any;
export type OcStore = Record<string, OcStoreValue>;

export interface OcMeta {
    /**
     * Error messages
     */
    errors: string[];
    /**
     * Field name path
     */
    name: InternalOcNamePath;
    /**
     * if is operated
     */
    touched: boolean;
    /**
     * if is validating
     */
    validating: boolean;
    /**
     * Warning messages
     */
    warnings: string[];
}

export interface InternalOcFieldData extends OcMeta {
    value: OcStoreValue;
}

/**
 * Used by `setFields` config
 */
export interface OcFieldData
    extends Partial<Omit<InternalOcFieldData, 'name'>> {
    name: OcNamePath;
}

export type OcRuleType =
    | 'string'
    | 'number'
    | 'boolean'
    | 'method'
    | 'regexp'
    | 'integer'
    | 'float'
    | 'object'
    | 'enum'
    | 'date'
    | 'url'
    | 'hex'
    | 'email';

export type OcRuleRender = (form: OcFormInstance) => OcRuleObject;

export interface OcValidatorRule {
    /**
     * The message
     */
    message?: string | ReactElement;
    /**
     * Required will only be a warning
     * Form submit will not be blocked
     */
    warningOnly?: boolean;
    /**
     * Custom validation rule
     * Accepts Promise as return
     */
    validator: Validator;
}

export type OcRuleObject = OcAggregationRule | OcArrayRule;

export type OcRule = OcRuleObject | OcRuleRender;

export interface OcValidateErrorEntity<Values = any> {
    values: Values;
    errorFields: { name: InternalOcNamePath; errors: string[] }[];
    outOfDate: boolean;
}

export interface OcFieldEntity {
    onStoreChange: (
        store: OcStore,
        namePathList: InternalOcNamePath[] | null,
        info: OcValuedNotifyInfo
    ) => void;
    isTouched: () => boolean;
    isDirty: () => boolean;
    isValidating: () => boolean;
    isListField: () => boolean;
    isList: () => boolean;
    isPreserve: () => boolean;
    validateRules: (options?: OcValidateOptions) => Promise<OcRuleError[]>;
    getMeta: () => OcMeta;
    getNamePath: () => InternalOcNamePath;
    getErrors: () => string[];
    getWarnings: () => string[];
    props: {
        name?: OcNamePath;
        rules?: OcRule[];
        dependencies?: OcNamePath[];
        initialValue?: any;
    };
}

export interface OcFieldError {
    name: InternalOcNamePath;
    errors: string[];
    warnings: string[];
}

export interface OcRuleError {
    errors: string[];
    rule: OcRuleObject;
}

export interface OcValidateOptions {
    triggerName?: string;
    validateMessages?: ValidateMessages;
    /**
     * Recursive validate
     * Will validate all the name path that contains the provided one
     * e.g. ['a'] will validate ['a'] , ['a', 'b'] and ['a', 1]
     */
    recursive?: boolean;
}

export type InternalOcValidateFields<Values = any> = (
    nameList?: OcNamePath[],
    options?: OcValidateOptions
) => Promise<Values>;

export type ValidateFields<Values = any> = (
    nameList?: OcNamePath[]
) => Promise<Values>;

export type OcNotifyInfo =
    | OcValueUpdateInfo
    | OcValidateFinishInfo
    | OcResetInfo
    | OcRemoveInfo
    | SetOcFieldInfo
    | OcDependenciesUpdateInfo;

export type OcValuedNotifyInfo = OcNotifyInfo & {
    store: OcStore;
};

export interface OcCallbacks<Values = any> {
    onValuesChange?: (changedValues: any, values: Values) => void;
    onFieldsChange?: (
        changedFields: OcFieldData[],
        allFields: OcFieldData[]
    ) => void;
    onFinish?: (values: Values) => void;
    onFinishFailed?: (errorInfo: OcValidateErrorEntity<Values>) => void;
}

export type WatchOcCallBack = (
    values: OcStore,
    namePathList: InternalOcNamePath[]
) => void;

export interface InternalOcHooks {
    dispatch: (action: ReducerAction) => void;
    initEntityValue: (entity: OcFieldEntity) => void;
    registerField: (entity: OcFieldEntity) => () => void;
    useSubscribe: (subscribable: boolean) => void;
    setInitialValues: (values: OcStore, init: boolean) => void;
    destroyForm: () => void;
    setCallbacks: (callbacks: OcCallbacks) => void;
    registerWatch: (callback: WatchOcCallBack) => () => void;
    getFields: (namePathList?: InternalOcNamePath[]) => OcFieldData[];
    setValidateMessages: (validateMessages: ValidateMessages) => void;
    setPreserve: (preserve?: boolean) => void;
    getInitialValue: (namePath: InternalOcNamePath) => OcStoreValue;
}

// Internal Form API
export interface OcFormInstance<Values = any> {
    /**
     * Gets the error messages by a field name
     */
    getFieldError: (name: OcNamePath) => string[];
    /**
     * Get the error messages by multiple fields' name
     */
    getFieldListErrors: (nameList?: OcNamePath[]) => OcFieldError[];
    /**
     * Gets values by a set of field names
     * return according to the corresponding structure
     * use getFieldListValues(true) to get all values
     * @default return mounted field value
     */
    getFieldListValues: (() => Values) &
        ((
            nameList: OcNamePath[] | true,
            filterFunc?: (meta: OcMeta) => boolean
        ) => any);
    /**
     * Gets the value by a field name
     */
    getFieldValue: (name: OcNamePath) => OcStoreValue;
    /**
     * Gets the warn messages by a field name
     */
    getFieldWarning: (name: OcNamePath) => string[];
    /**
     * Check if fields have been operated
     * Check if all fields is touched when allTouched is true
     */
    isListTouched: ((
        nameList?: OcNamePath[],
        allFieldsTouched?: boolean
    ) => boolean) &
        ((allFieldsTouched?: boolean) => boolean);
    /**
     * Check if multiple fields are validating
     */
    isListValidating: (nameList: OcNamePath[]) => boolean;
    /**
     * Check if a field has been operated
     */
    isTouched: (name: OcNamePath) => boolean;
    /**
     * Check if a field is validating
     */
    isValidating: (name: OcNamePath) => boolean;
    /**
     * Reset fields to initialValues
     */
    resetFields: (fields?: OcNamePath[]) => void;
    /**
     * Set multiple fields status
     */
    setFields: (fields: OcFieldData[]) => void;
    /**
     * Set multiple fields' value
     * Will directly pass to form store
     * If you do not want to modify passed object, clone first
     * Use setFieldValue instead if you want to only config single value in Form.List
     */
    setFieldListValues: (values: RecursiveOcPartial<Values>) => void;
    /**
     * Set a single field value
     * Will directly pass to form store
     * If you do not want to modify passed object, clone first
     */
    setFieldValue: (name: OcNamePath, value: any) => void;
    /**
     * Submit the form
     * Equivalent to submit button click
     */
    submit: () => void;
    /**
     * Validate fields
     */
    validateFields: ValidateFields<Values>;
}

export type InternalOcFormInstance = Omit<OcFormInstance, 'validateFields'> & {
    /**
     * Validate fields
     */
    validateFields: InternalOcValidateFields;
    /**
     * Passed by field context props
     */
    prefixName?: InternalOcNamePath;
    /**
     * Determine when to validate the value of children node
     */
    validateTrigger?: string | string[] | false;
    /**
     * Form component should register some content into store.
     * We pass the `HOOK_MARK` as key to avoid user call the function.
     */
    getInternalHooks: (secret: string) => InternalOcHooks | null;
    /**
     * @private Internal usage only
     * Do not use in production
     */
    _init?: boolean;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type OcEventArgs = any[];

export interface ValidateMessages {
    default?: OcValidateMessage;
    required?: OcValidateMessage;
    enum?: OcValidateMessage;
    whitespace?: OcValidateMessage;
    date?: {
        format?: OcValidateMessage;
        parse?: OcValidateMessage;
        invalid?: OcValidateMessage;
    };
    types?: {
        string?: OcValidateMessage;
        method?: OcValidateMessage;
        array?: OcValidateMessage;
        object?: OcValidateMessage;
        number?: OcValidateMessage;
        date?: OcValidateMessage;
        boolean?: OcValidateMessage;
        integer?: OcValidateMessage;
        float?: OcValidateMessage;
        regexp?: OcValidateMessage;
        email?: OcValidateMessage;
        url?: OcValidateMessage;
        hex?: OcValidateMessage;
    };
    string?: {
        len?: OcValidateMessage;
        min?: OcValidateMessage;
        max?: OcValidateMessage;
        range?: OcValidateMessage;
    };
    number?: {
        len?: OcValidateMessage;
        min?: OcValidateMessage;
        max?: OcValidateMessage;
        range?: OcValidateMessage;
    };
    array?: {
        len?: OcValidateMessage;
        min?: OcValidateMessage;
        max?: OcValidateMessage;
        range?: OcValidateMessage;
    };
    pattern?: {
        mismatch?: OcValidateMessage;
    };
}

export type BaseOcFormProps = Omit<
    React.FormHTMLAttributes<HTMLFormElement>,
    'onSubmit' | 'children'
>;

export type OcRenderProps = (
    values: OcStore,
    form: OcFormInstance
) => JSX.Element | React.ReactNode;

export interface OcFormProps<Values = any> extends BaseOcFormProps {
    /**
     * The Form children
     */
    children?: OcRenderProps | React.ReactNode;
    /**
     * Set the Form rendering element
     * Do not create a DOM node if false
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    component?: false | string | React.FC<any> | React.ComponentClass<any>;
    /**
     * Control of Form fields through state management
     */
    fields?: OcFieldData[];
    /**
     * Form control instance created by Form.useForm()
     * Automatically created when not provided
     */
    form?: OcFormInstance<Values>;
    /**
     * Set value by Form initialization or reset
     */
    initialValues?: OcStore;
    /**
     * The Form name.
     */
    name?: string;
    /**
     * Trigger when field updated
     */
    onFieldsChange?: OcCallbacks<Values>['onFieldsChange'];
    /**
     * Trigger after submitting the form and verifying data successfully
     */
    onFinish?: OcCallbacks<Values>['onFinish'];
    /**
     * Trigger after submitting the form and verifying data failed
     */
    onFinishFailed?: OcCallbacks<Values>['onFinishFailed'];
    /**
     * Trigger when value updated
     */
    onValuesChange?: OcCallbacks<Values>['onValuesChange'];
    /**
     * Keep field value even when field is removed
     */
    preserve?: boolean;
    /**
     * Validation message prompts
     */
    validateMessages?: ValidateMessages;
    /**
     * Determine when to validate the value of children node
     */
    validateTrigger?: string | string[] | false;
}

export type ShouldUpdate<Values = any> =
    | boolean
    | ((
          prevValues: Values,
          nextValues: Values,
          info: { source?: string }
      ) => boolean);

// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style
export interface OcChildProps {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [name: string]: any;
}

export interface OcListField {
    name: number;
    key: number;
    isListField: boolean;
}

export interface OcListOperations {
    /**
     * Add a Form.Item
     */
    add: (defaultValue?: OcStoreValue, index?: number) => void;
    /**
     * Move a Form.Item
     */
    move: (from: number, to: number) => void;
    /**
     * Remove a Form.Item
     */
    remove: (index: number | number[]) => void;
}

export interface OcListProps {
    /**
     * The render function
     */
    children?: (
        fields: OcListField[],
        operations: OcListOperations,
        meta: OcMeta
    ) => JSX.Element | React.ReactNode;
    /**
     * Configure sub default value
     * Form initialValues get higher priority
     */
    initialValue?: any[];
    /**
     * Field name, supports array
     */
    name: OcNamePath;
    /**
     * Validate rules
     * only supports customized validator
     */
    rules?: OcValidatorRule[];
    /**
     * When to validate the value of children node
     */
    validateTrigger?: string | string[] | false;
}

export interface InternalOcFieldProps<Values = any> {
    /**
     * The Field children
     */
    children?:
        | React.ReactElement
        | ((
              control: OcChildProps,
              meta: OcMeta,
              form: OcFormInstance<Values>
          ) => React.ReactNode);
    /**
     * Set up `dependencies` field
     * When dependencies field update and current field is touched
     * will trigger validate rules and render
     */
    dependencies?: OcNamePath[];
    /**
     * Specify how to get value from event or other onChange arguments
     */
    getValueFromEvent?: (...args: OcEventArgs) => OcStoreValue;
    /**
     * Additional props with sub component
     */
    getValueProps?: (value: OcStoreValue) => Record<string, unknown>;
    /**
     * Config sub default value
     * Form initialValues get higher priority
     */
    initialValue?: any;
    /**
     * The default validate field info
     */
    messageVariables?: Record<string, string>;
    /**
     * The Field name
     * supports array
     */
    name?: InternalOcNamePath;
    /**
     * Normalize value from component value before passing to Form instance
     * Does not support async
     */
    normalize?: (
        value: OcStoreValue,
        prevValue: OcStoreValue,
        allValues: OcStore
    ) => OcStoreValue;
    /**
     * The onMeta change event
     * Called when fields are dynamically added/removed
     */
    onMetaChange?: (meta: OcMeta & { destroy?: boolean }) => void;
    /**
     * The onReset callback
     */
    onReset?: () => void;
    /**
     * Keep field value even when field is removed
     */
    preserve?: boolean;
    /**
     * Rules for field validation
     */
    rules?: OcRule[];
    /**
     * Custom field update logic
     */
    shouldUpdate?: ShouldUpdate<Values>;
    /**
     * When to collect the value of children node
     */
    trigger?: string;
    /**
     * Whether stop validate on first rule of error for this field
     * Will parallel validate when parallel configured
     */
    validateFirst?: boolean | 'parallel';
    /**
     * Props of children node, i.e. the prop of Switch is 'checked'.
     * This prop is an encapsulation of `getValueProps`,
     * which will be invalid after customizing `getValueProps`
     */
    valuePropName?: string;
    /**
     * When to validate the value of children node
     */
    validateTrigger?: string | string[] | false;
    /**
     * @private Pass context as prop instead of context api
     * since class component can not get context in constructor
     */
    fieldContext?: InternalOcFormInstance;
    /**
     * @private Passed by Form.List props
     * Do not use since it will break by path check
     */
    isList?: boolean;
    /**
     * @private Passed by Form.List props
     * Do not use since it will break by path check
     */
    isListField?: boolean;
}

export interface OcFieldProps<Values = any>
    extends Omit<InternalOcFieldProps<Values>, 'name' | 'fieldContext'> {
    name?: OcNamePath;
}

export interface OcFieldState {
    resetCount: number;
}
